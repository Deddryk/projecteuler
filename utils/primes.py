# Author: Deddryk
"""
Utilities for dealing with prime numbers.

gen_primes(limit, file='primes'):
Generate primes up to limit store in file file using the pickle library

load_primes(file=primes):
Load the primes generated with gen_primes.
Return them as a list

"""

DEFAULT_PRIME_LIMIT = 2000000
DEFAULT_NUM_TRIALS = 5

from math import sqrt
import pickle
import random

random.seed()

def gen_primes(limit=DEFAULT_PRIME_LIMIT, file_name=0):
    """
    Generate all primes less than limit and pickle to file if needed.
    
    This function uses a sieve to generate the primes under the given
    limit.  As such is it efficient only for generating small primes.
    For generating large primes use more modern methods.

    Return the list of primes generated.

    Do not provide a file_name argument if primes do not need to be
    stored.

    """
    prime_list = []
    sieve = [True] * limit
    cur_prime = 2
    while cur_prime <= int(sqrt(limit)):
        if sieve[cur_prime]:
            prime_list.append(cur_prime)
            for i in xrange(2 * cur_prime, limit, cur_prime):
                sieve[i] = False
        cur_prime += 1
    for i in xrange(cur_prime + 1, limit):
        if sieve[i]:
            prime_list.append(i)
    if file_name != 0:
        f = open(file_name, 'w')
        pickle.dump(prime_list, f)
    return prime_list

def load_primes(file_name='primes', auto_gen=True):
    """
    Load prime numbers generated by gen_primes from file
    Return the list of primes

    This function will automatically generate the file if it is not
    found.  To disable this behavior, provide the argument
    auto_gen=False

    If auto_gen=false and the file is not found return an empty list

    """
    try:
        with open(file_name, 'r') as f:
            return pickle.load(f)
    except IOError:
        if not auto_gen:
            return []
        return gen_primes(file_name=file_name)

def factor(x, prime_list=load_primes()):
    """
    Factor x into its prime factorization.

    Return a dictionary of the form {prime: power...}

    prime_list must be an ordered list of primes used to perform the
    factoring.  Behavior is undefined if the list does not contatain x's
    largest prime factor.

    """
    factorization = dict()
    i = 0
    while prime_list[i] <= int(sqrt(x)):
        prime = prime_list[i]
        if x % prime == 0:
            factorization[prime] = 0
        while x % prime == 0:
            factorization[prime] += 1
            x /= prime
        i += 1
    if x != 1:
        factorization[x] = 1
    return factorization

def sum_of_divisors(n):
    """
    Calculate the sum of proper divisors of n
    
    """
    factors = factor(n)
    sod = 1
    for prime in factors:
        sod *= (prime**(factors[prime] + 1) - 1) / (prime-1)
    return sod - n

def probable_prime(n, num_trials=DEFAULT_NUM_TRIALS):
    """
    Determine if n (an odd integer) is probably prime.

    Using the Miller-Rabin primality test, determine if n is probably prime.
    Probablility of falsly reported priems is 4^-(num_trials)

    """
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    s = 0
    d = n - 1
    while d % 2 == 0:
        s += 1
        d /= 2
    assert(2**s * d == n - 1)

    def try_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in xrange(s):
            if pow(a, 2**i * d, n) == n - 1:
                return False
        return True

    for i in xrange(num_trials):
        a = random.randrange(2, n)
        if try_composite(a):
            return False
    return True
